<!DOCTYPE html>
<meta charset="utf-8">

<style type="text/css">

	body {	
		width: 600px;
		margin: 20px auto;
		font-family: helvetica;
		font-size: 16px;
	}

	.title {
		text-align: center;
		font-family: Baskerville, "Baskerville Old Face", "Goudy Old Style", Garamond, "Times New Roman", serif;
		font-size: 44px;
	}

	.axis path {
		fill:#f2f2f2;
		fill-opacity:.3;
		stroke:#cccccc;
		stroke-width:1;
	}

	.axis text {
		/*font: 15px sans-serif;*/
		font-family: helvetica;
		fill: gray;
	}

	.axis line {
		stroke: #bfbfbf;
		stroke-width: 1;
		stroke-dasharray: 3;
	}

	.buttonsGroup {
		padding:23px;
	}

	.buttonsDiv {
		width: 540px;
		margin: 0 auto;
	}

	.dummyline {
    stroke: none;
    stroke-width: 0px;
    /*stroke-opacity: 0.75;*/
  	}

  	.trendline {
    /*stroke: red;*/
    stroke-width: 3px;
    /*stroke-opacity: 0.75;*/
  	}

</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js" charset="utf-8"></script>
<!-- <script src="d3.min.js" charset="utf-8"></script> -->


<body>

	<script>
	//To Do
	//bring hover-overed elements to fore
	//add clickability to radio button labels
	//add stats display for each dataset
	//further develop trend line animations
	//fewer ticks on axis (halve?)
	//faint grid lines

	//IDEAS
	//use .on to display exact coordinates on hover over, but display them just outside the tick text of the axes, and in blue


		// d3.selection.prototype.moveToFront = function() {
		// 	return this.each(function(){
		// 		this.parentNode.appendChild(this);
		// 	});
		// };

		var margin = {top: 8, right: 30, bottom: 25, left: 30};

		var width = 600 - margin.left - margin.right,
			height = 600 - margin.top - margin.bottom;

		var xScale = d3.scale.linear()
			.range ([0, width]);

		var yScale = d3.scale.linear()
			.range ([height, 0]);

		var ticknum = 10

		var numSteps = 20

		var xAxis = d3.svg.axis()
			.scale(xScale)
			.ticks(ticknum)
			.tickSize(-height)
			.tickPadding(10)
			.orient("bottom");

		var yAxis = d3.svg.axis()
			.scale(yScale)
			.ticks(ticknum)
			.tickSize(-width)
			.tickPadding(10)
			.orient("left");

		//delete
		// d3.select("body").transition().style("color", "red");

		d3.tsv("quartet.tsv", function(error, quartetData) {
			if (error) return console.warn(error);

			quartetData.forEach(function(d) {
				d.x = +d.x;
				d.y = +d.y;
			});

			var nestedQuartetData = d3.nest()
			.key(function(d) { return d.group })
			.entries(quartetData);

			window.nestedQuartetData = nestedQuartetData

			var title = d3.select("body").append("h2")
				.text("Anscombe's Quartet")
				.attr("class","title");

			var buttonsDiv = d3.select("body").append("div")
				.attr("class","buttonsDiv");

			var container = d3.select("body").append("div");

			var buttonsGroup = buttonsDiv.selectAll(".buttonsGroup")
				.data(nestedQuartetData)
			  .enter().append("g")
			  	.attr("class", "buttonsGroup");

			var colorScale = d3.scale.ordinal()
			.range(["#377eb8","#4daf4a","#984ea3","#ff7f00"]);;

			var buttons = buttonsGroup.append("input")
				.attr({
					type:"radio",
					class:"buttons",
					name:"groupNum",
					ID:(function(d) { return " Group " + d.key }),
				})
				.on("change", function (d) { updateData(d.values) })

			buttonsGroup.append("label")
				.text(function(d) { return " Group " + d.key + " " })
				.attr("for", (function(d) { return " Group " + d.key }))
				.style("background-color", function(d) { return colorScale(d.key) })
				.style("color", "white");

			var svg = container.append("svg")
			   .attr("width", width + margin.left + margin.right)
			   .attr("height", height + margin.top + margin.bottom)
			   .append("g")
			   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var eqText = svg.append("text")
			.attr("id", "eq-text")
			.style("text-anchor", "start")
			.attr("x", 12)
			.attr("y", 20);

			var data1 = quartetData.filter(function(d) { return d.group == 'I'; });
			var data2 = quartetData.filter(function(d) { return d.group == 'II'; });
			var data3 = quartetData.filter(function(d) { return d.group == 'III'; });
			var data4 = quartetData.filter(function(d) { return d.group == 'IV'; });


			var adjustedXMin = d3.min(data3, function(d) { return d.x-1 });
			var adjustedXMax = d3.max(data3, function(d) { return d.x+1 });

			var adjustedYMin = d3.min(data3, function(d) { return d.y-1});
			var adjustedYMax = d3.max(data3, function(d) { return d.y+1 });

			xScale.domain([0, 20]).nice();
			yScale.domain([0, 20]).nice();

			svg.append("g")
				.attr("class", "x axis")
				.attr("transform", "translate (0, " + height + ")" )
				.call(xAxis);

			svg.append("g")
				.attr("class", "y axis")
				.call(yAxis);
			
			var circlegroup = svg.selectAll(".anscombeCircleGroup")
			.data(data1)

		  .enter()
			.append("g")
			.attr("class","anscombeCircleGroup")
			.attr("transform", function(d) { return "translate(" + xScale(d.x) + "," + yScale(d.y) + ")" });

			circlegroup.append("text")
		   .attr("class",function(d,i) { return "T" + i })
		   .attr("dx", 12)
		   .attr("dy", 10)
		   .text(function(d) { return d.x + ", " + d.y; })
		   .style("fill","none")
		   .style("font","12px sans-serif")

			circlegroup.append("circle")
			.attr("class",function(d,i) { return "anscombeCircles T" + i; })
			.attr("r", 7)
			.style("fill", function(d) { return colorScale(d.group) })
			.on("mouseover",function(){
				var sel = d3.select(this);
				sel.moveToFront();
			})
			.on("mouseenter", function() {
				var mouseClass = d3.select(this).attr("class").split(" ")[1];
				d3.selectAll("." + mouseClass)
				.style("fill", "black")
			})
			.on("mouseleave", function() {
				d3.selectAll(".anscombeCircleGroup")
				.selectAll("text")
				.style("fill", "none")

				d3.selectAll(".anscombeCircles")
				.style("fill",function(d) { return colorScale(d.group) })
			});
		    
			
			updateData(data1);
			
			function updateData(currentData) {

				console.log(currentData);

				d3.selectAll(".trendline").remove()
				// d3.selectAll(".dummyline").remove()

				var xSeries = currentData.map(function(d) { return parseFloat(d['x']); });
			    var ySeries = currentData.map(function(d) { return parseFloat(d['y']); });
			    
			    // console.log('xSeries: ' + xSeries);
			    // console.log('ySeries: ' + ySeries);

			    var leastSquaresCoeff = leastSquares(xSeries, ySeries);

			    var slope = leastSquaresCoeff[0];
			    var intercept = leastSquaresCoeff[1];
			    var rSquare = leastSquaresCoeff[2];

			    // console.log("slope: " + slope);
			    // console.log("intercept: " + intercept);

			    var dumdumline = svg.selectAll(".dumdumline")
			    	.data(currentData)
			      .enter()
			      	.append("line")
			      	.attr("class","dumdumline")
			      	.attr("x1", xScale(0))
			        .attr("y1", yScale(intercept))
			        .attr("x2", xScale(numSteps))
			        .attr("y2", yScale(numSteps*slope + intercept))

			    d3.selectAll(".dumdumline")
			    	.transition()
			        .duration(1800)
			        .delay(800)
			    	.style("stroke", function(d) { console.log(colorScale(d.group)); return colorScale(d.group) });
		    	
		    	var trendline = svg
			    	.selectAll(".trendline")
			    	.data(currentData)
			      .enter()
			    	.append("line")
			    	.attr("class", "trendline")
			    	.attr("stroke-dasharray", 610 + " " + 610)
	        		.attr("stroke-dashoffset", 610)
			        .attr("x1", xScale(0))
			        .attr("y1", yScale(intercept))
			        .attr("x2", xScale(numSteps))
			        .attr("y2", yScale(numSteps*slope + intercept))
			    	.style("stroke", function(d) { return colorScale(d.group) });

			   	d3.selectAll(".trendline")
			        .transition()
			        .duration(900)
			        .ease("quad")
			        .attr("stroke-dashoffset", 0)
			        .transition()
			    	.delay(950)
			    	.duration(1200)
			    	.ease("linear")
			    	.style("stroke-width", "1px");
				
				svg.selectAll(".anscombeCircleGroup")
					.data(currentData)
					.transition()
					.ease("elastic")
					.attr("class","anscombeCircleGroup")
					.attr("transform", function(d) { return "translate(" + xScale(d.x) + "," + yScale(d.y) + ")" })
					.select("circle")
					.style("fill", function(d) { return colorScale(d.group) });

		        var format2d = d3.format("0.1f");

			    d3.select('#eq-text').text("y = " + format2d(slope) 
			                                + "x + " + format2d(intercept))
			    .transition()
			    .style("color", "red")
			    // .duration(500)
			    // .ease("cubic");

				function leastSquares(xSeries, ySeries) {
					var reduceSumFunc = function(prev, cur) { return prev + cur; };
					
					var xBar = xSeries.reduce(reduceSumFunc) * 1.0 / xSeries.length;
					var yBar = ySeries.reduce(reduceSumFunc) * 1.0 / ySeries.length;

					var ssXX = xSeries.map(function(d) { return Math.pow(d - xBar, 2); })
						.reduce(reduceSumFunc);
					
					var ssYY = ySeries.map(function(d) { return Math.pow(d - yBar, 2); })
						.reduce(reduceSumFunc);
						
					var ssXY = xSeries.map(function(d, i) { return (d - xBar) * (ySeries[i] - yBar); })
						.reduce(reduceSumFunc);
						
					var slope = ssXY / ssXX;
					var intercept = yBar - (xBar * slope);
					var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);
					
					return [slope, intercept, rSquare];
				}
			}

			d3.select(".buttons")
             .attr("checked","checked")

		});


	</script>

</body>